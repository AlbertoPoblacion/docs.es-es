---
title: Metadatos de las propiedades de dependencia
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 3d84510fce69e81929cbe9b6088e12aaf3409769
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186366"
---
# <a name="dependency-property-metadata"></a>Metadatos de las propiedades de dependencia
El [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] sistema de propiedades incluye un sistema de informes de metadatos que va más allá de lo que se puede notificar sobre una propiedad a través de características de reflexión o Common Language Runtime (CLR) general. Los metadatos de una propiedad de dependencia también los puede asignar de manera exclusiva la clase que define una propiedad de dependencia, se pueden cambiar cuando la propiedad de dependencia se agrega a una clase diferente y los pueden invalidar específicamente todas las clases derivadas que heredan la propiedad de dependencia de la clase base de definición.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Requisitos previos  
 En este tema, se supone que entiende las propiedades de dependencia desde la perspectiva de un consumidor de propiedades de dependencia existentes en las clases [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] y que ha leído [Información general sobre las propiedades de dependencia](dependency-properties-overview.md). Para seguir los ejemplos de este tema, también debe comprender [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y saber cómo escribir aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a>Uso de los metadatos de las propiedades de dependencia  
 Los metadatos de las propiedades de dependencia existen como un objeto que se puede consultar para examinar las características de una propiedad de dependencia. El sistema de propiedades también accede con frecuencia a estos metadatos mientras procesa cualquier propiedad de dependencia determinada. El objeto de metadatos de una propiedad de dependencia puede contener los siguientes tipos de información:  
  
- Valor predeterminado para la propiedad de dependencia, si no se puede determinar ningún otro valor para la propiedad de dependencia por valor local, estilo, herencia, etc. Para obtener una explicación exhaustiva de cómo participan los valores predeterminados en la prioridad utilizada por el sistema de propiedades al asignar valores para las propiedades de dependencia, vea Prioridad del valor de propiedad de [dependencia](dependency-property-value-precedence.md).  
  
- Referencias a las implementaciones de devoluciones de llamada que afectan a los comportamientos de coerción o notificación de cambios por tipo de propietario. Tenga en cuenta que estas devoluciones de llamada se definen a menudo con un nivel de acceso no público, de modo que obtener las referencias reales de los metadatos no suele ser posible a menos que estén dentro de su ámbito de acceso permitido. Para obtener más información sobre las devoluciones de llamada de propiedades de dependencia, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](dependency-property-callbacks-and-validation.md).  
  
- Si la propiedad de dependencia en cuestión se considera una propiedad del nivel de marco de WPF, los metadatos podrían contener características de propiedades de dependencia del nivel de marco de WPF, que comunican los datos y el estado de los servicios, tales como la lógica de herencia de propiedades y el motor de diseño del nivel de marco de WPF. Para obtener más información sobre este aspecto de los metadatos de propiedades de dependencia, consulte [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md).  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a>API de metadatos  
 El tipo que notifica la mayor parte de <xref:System.Windows.PropertyMetadata> la información de metadatos utilizada por el sistema de propiedades es la clase. Las instancias de metadatos se especifican de manera opcional cuando las propiedades de dependencia se registran con el sistema de propiedades y pueden especificarse de nuevo para tipos adicionales que se agreguen a sí mismos como propietarios o invaliden los metadatos que heredan de la definición de propiedad de dependencia de clase base. (Para los casos en los que un <xref:System.Windows.PropertyMetadata> registro de propiedad no especifica metadatos, se crea un valor predeterminado con valores predeterminados para esa clase.) Los metadatos registrados <xref:System.Windows.PropertyMetadata> se devuelven <xref:System.Windows.DependencyProperty.GetMetadata%2A> como cuando se llama a <xref:System.Windows.DependencyObject> las distintas sobrecargas que obtienen metadatos de una propiedad de dependencia en una instancia.  
  
 A <xref:System.Windows.PropertyMetadata> continuación, la clase se deriva para proporcionar metadatos más específicos para las divisiones de arquitectura, como las clases de nivel de marco de WPFWPF. <xref:System.Windows.UIPropertyMetadata>agrega informes de <xref:System.Windows.FrameworkPropertyMetadata> animación y proporciona las propiedades de nivel de marco de WPF mencionadas en la sección anterior. Cuando se registran las propiedades de <xref:System.Windows.PropertyMetadata> dependencia, se pueden registrar con estas clases derivadas. Cuando se examinan los <xref:System.Windows.PropertyMetadata> metadatos, el tipo base se puede convertir potencialmente a las clases derivadas para que pueda examinar las propiedades más específicas.  
  
> [!NOTE]
> Las características de propiedad que <xref:System.Windows.FrameworkPropertyMetadata> se pueden especificar en a veces se conocen en esta documentación como "banderas". Cuando se crean nuevas instancias de metadatos para su uso en registros de <xref:System.Windows.FrameworkPropertyMetadataOptions> propiedades de dependencia o invalidaciones de <xref:System.Windows.FrameworkPropertyMetadata> metadatos, se especifican estos valores mediante la enumeración flagwise y, a continuación, se proporcionan valores posiblemente concatenados de la enumeración al constructor. Sin embargo, una vez construidas, <xref:System.Windows.FrameworkPropertyMetadata> estas características de opción se exponen dentro de una serie de propiedades booleanas en lugar del valor de enumeración de construcción. Las propiedades booleanas permiten comprobar cada condicional, en lugar de exigir que aplique una máscara a un valor de enumeración basada en marcas para obtener la información que le interesa. El constructor utiliza <xref:System.Windows.FrameworkPropertyMetadataOptions> el concatenado con el fin de mantener la longitud de la firma del constructor razonable, mientras que los metadatos reales construidos expone las propiedades discretas para hacer que la consulta de los metadatos más intuitiva.  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Cuándo invalidar metadatos y cuándo derivar una clase  
 El sistema de propiedades de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tiene funcionalidades establecidas para modificar algunas características de las propiedades de dependencia sin necesidad de volver a implementarlas completamente. Esto se logra construyendo una instancia diferente de los metadatos de la propiedad de dependencia tal como existe en un tipo determinado. Tenga en cuenta que la mayoría de las propiedades de dependencia existentes no son propiedades virtuales, de modo que, en el sentido estricto, su "reimplementación" en clases heredadas solo se puede lograr mediante el sombreado del miembro existente.  
  
 Si el escenario que intenta habilitar para una propiedad de dependencia en un tipo no se puede lograr con la modificación de las características de las propiedades de dependencia existentes, podría ser necesario crear una clase derivada y, después, declarar una propiedad de dependencia personalizada en su clase derivada. Una propiedad de dependencia personalizada se comporta de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] forma idéntica a las propiedades de dependencia definidas por las API. Para obtener más información acerca de las propiedades de dependencia personalizadas, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md).  
  
 Una característica importante de una propiedad de dependencia que no se puede invalidar es su tipo de valor. Si hereda una propiedad de dependencia que tiene el comportamiento aproximado que necesita, pero necesita que tenga un tipo diferente, tendrá que implementar una propiedad de dependencia personalizada y, posiblemente, vincular las propiedades mediante la conversión de tipos u otra implementación en la clase personalizada. Además, no <xref:System.Windows.ValidateValueCallback>puede reemplazar una existente, porque esta devolución de llamada existe en el propio campo de registro y no dentro de sus metadatos.  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a>Escenarios para modificar los metadatos existentes  
 Si está trabajando con los metadatos de una propiedad de dependencia existente, un escenario común para cambiar dichos metadatos es cambiar el valor predeterminado. Cambiar o agregar devoluciones de llamada del sistema de propiedades es un escenario más avanzado. Es posible que quiera hacerlo si su implementación de una clase derivada tiene diferentes interrelaciones entre las propiedades de dependencia. Uno de los condicionales de tener un modelo de programación que admita tanto el uso declarativo como de código es que las propiedades deben poder establecerse en cualquier orden. Por lo tanto, las propiedades dependientes deben establecerse Just-in-Time sin contexto y no pueden depender de saber un orden de configuración como podría darse en un constructor. Para obtener más información sobre este aspecto del sistema de propiedades, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](dependency-property-callbacks-and-validation.md). Tenga en cuenta que las devoluciones de llamada de validación no forman parte de los metadatos, sino del identificador de la propiedad de dependencia. Por lo tanto, las devoluciones de llamada de validación no se pueden cambiar mediante la invalidación de los metadatos.  
  
 Es posible que en algunos casos también quiera modificar las opciones de metadatos de la propiedad del nivel de marco de WPF en las propiedades de dependencia existente. Estas opciones comunican determinados condicionales conocidos acerca de las propiedades del nivel de marco de WPF a otros procesos del nivel de marco de WPF, como el sistema de diseño.  Establecer las opciones se realiza generalmente solo cuando se registra una nueva propiedad de dependencia, pero <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> también <xref:System.Windows.DependencyProperty.AddOwner%2A> es posible cambiar los metadatos de propiedad de nivel de marco de WPFWPF como parte de una llamada o. Para obtener los valores específicos que se van a usar y otros datos, consulte [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md). Para obtener más información relativa a cómo deben establecerse estas opciones para una propiedad de dependencia recién registrada, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a>Invalidar metadatos  
 El propósito de invalidar metadatos es principalmente que tenga la oportunidad de cambiar los distintos comportamientos derivados de metadatos que se aplican a la propiedad de dependencia tal como existe en el tipo. Las razones para ello se explican con más detalle en la sección [Metadatos](#dp_metadata_contents). Para obtener más información, incluidos algunos ejemplos de código, consulte [Invalidar metadatos en una propiedad de dependencia](how-to-override-metadata-for-a-dependency-property.md).  
  
 Los metadatos de propiedad se pueden proporcionar<xref:System.Windows.DependencyProperty.Register%2A>para una propiedad de dependencia durante la llamada de registro ( ). Sin embargo, en muchos casos, es posible que quiera proporcionar metadatos específicos del tipo para la clase cuando esta herede esa propiedad de dependencia. Puede hacerlo llamando al <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método.  Para obtener un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ejemplo de <xref:System.Windows.FrameworkElement> las API, la clase <xref:System.Windows.UIElement.Focusable%2A> es el tipo que primero registra la propiedad de dependencia. Pero <xref:System.Windows.Controls.Control> la clase reemplaza los metadatos de la propiedad de dependencia `false` `true`para proporcionar su propio <xref:System.Windows.UIElement.Focusable%2A> valor predeterminado inicial, cambiándolo de a , y de lo contrario reutiliza la implementación original.  
  
 Si invalida los metadatos, las distintas características de los metadatos se combinan o se reemplazan.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>se fusiona. Si agrega un <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>nuevo , esa devolución de llamada se almacena en los metadatos. Si no especifica <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> a en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se promueve como una referencia desde el antecesor más cercano que lo especificó en los metadatos.  
  
- El comportamiento real <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> del sistema de propiedades es que las implementaciones para todos los propietarios de metadatos de la jerarquía se conservan y se agregan a una tabla, con el orden de ejecución por el sistema de propiedades siendo que las devoluciones de llamada de la clase más derivada se invocan primero.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>se sustituye. Si no especifica <xref:System.Windows.PropertyMetadata.DefaultValue%2A> a en la invalidación, el valor del <xref:System.Windows.PropertyMetadata.DefaultValue%2A> antecesor más cercano que lo especificó en los metadatos.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>se sustituyen las implementaciones. Si agrega un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>nuevo , esa devolución de llamada se almacena en los metadatos. Si no especifica <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> a en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se promueve como una referencia desde el antecesor más cercano que lo especificó en los metadatos.  
  
- El comportamiento del sistema <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de propiedades es que solo se invocan los metadatos inmediatos. No se <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> conservan las referencias a otras implementaciones de la jerarquía.  
  
 Este comportamiento se <xref:System.Windows.PropertyMetadata.Merge%2A>implementa mediante , y se puede invalidar en clases de metadatos derivadas.  
  
#### <a name="overriding-attached-property-metadata"></a>Invalidar los metadatos de las propiedades adjuntas  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], las propiedades adjuntas se implementan como propiedades de dependencia. Esto significa que también tienen metadatos de propiedad, que las clases individuales pueden invalidar. Las consideraciones de ámbito para [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] una propiedad adjunta <xref:System.Windows.DependencyObject> en son generalmente que cualquiera puede tener una propiedad adjunta establecida en ellos. Por lo <xref:System.Windows.DependencyObject> tanto, cualquier clase derivada puede invalidar los metadatos de cualquier propiedad adjunta, ya que podría establecerse en una instancia de la clase. Puede invalidar valores predeterminados, devoluciones de llamada o propiedades de informes de características del nivel de marco de WPF. Si se establece la propiedad adjunta en una instancia de la clase, se aplicarán las características de invalidación de metadatos de propiedad. Por ejemplo, puede invalidar el valor predeterminado, de modo que el valor de invalidación se notifique como el valor de la propiedad adjunta en las instancias de la clase, siempre que la propiedad no esté establecida de otro modo.  
  
> [!NOTE]
> La <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propiedad no es relevante para las propiedades adjuntas.  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Agregar una clase como propietaria de una propiedad de dependencia existente  
 Una clase puede agregarse a sí misma como propietario de <xref:System.Windows.DependencyProperty.AddOwner%2A> una propiedad de dependencia que ya se ha registrado, mediante el método. Esto permite que la clase use una propiedad de dependencia que se registró originalmente para un tipo diferente. La clase que se agrega no suele ser una clase derivada del tipo que registró inicialmente esa propiedad de dependencia como propietaria. De hecho, esto permite que la clase y sus clases derivadas "hereden" una implementación de propiedad de dependencia sin que la clase propietaria original y la clase que se agrega estén en la misma jerarquía de clases real. Además, la clase que se agrega (y también todas las clases derivadas) pueden proporcionar metadatos específicos del tipo para la propiedad de dependencia original.  
  
 Además de agregarse a sí misma como propietaria a través de los métodos de utilidad del sistema de propiedades, la clase que se agrega debe declarar miembros públicos adicionales en sí misma para convertir la propiedad de dependencia en un participante completo en el sistema de propiedades, con exposición para el código y la marcación. Una clase que agrega una propiedad de dependencia existente tiene las mismas responsabilidades en cuanto a exponer el modelo de objetos para esa propiedad de dependencia que una clase que define una nueva propiedad de dependencia personalizada. El primer miembro de este tipo que se va a exponer es un campo de identificador de propiedad de dependencia. Este campo debe `public static readonly` ser <xref:System.Windows.DependencyProperty>un campo de tipo , <xref:System.Windows.DependencyProperty.AddOwner%2A> que se asigna al valor devuelto de la llamada. El segundo miembro que se va a definir es la propiedad "wrapper" de Common Language Runtime (CLR). El contenedor hace que sea mucho más conveniente manipular la <xref:System.Windows.DependencyObject.SetValue%2A> propiedad de dependencia en el código (se evitan las llamadas a cada vez y puede realizar esa llamada solo una vez en el propio contenedor). El contenedor se implementa de forma idéntica a cómo se implementaría si se estuviera registrando una propiedad de dependencia personalizada. Para obtener más información acerca de cómo implementar una propiedad de dependencia, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md) y [Agregar un tipo de propietario para una propiedad de dependencia](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner y propiedades adjuntas  
 Puede llamar <xref:System.Windows.DependencyProperty.AddOwner%2A> a una propiedad de dependencia definida como una propiedad adjunta por la clase de propietario. Generalmente, el motivo para hacerlo es exponer la propiedad adjunta anteriormente como una propiedad de dependencia no adjunta. A continuación, <xref:System.Windows.DependencyProperty.AddOwner%2A> expondrá el `public static readonly` valor devuelto como un campo para su uso como identificador de propiedad de dependencia y definirá las propiedades de "envoltorio" adecuadas para que la propiedad aparezca en la tabla members y admita un uso de propiedad no adjunta en la clase.  
  
## <a name="see-also"></a>Consulte también

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Descripción general de las propiedades de dependencia](dependency-properties-overview.md)
- [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md)
