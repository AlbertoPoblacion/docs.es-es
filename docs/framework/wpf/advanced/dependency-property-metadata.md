---
title: Metadatos de las propiedades de dependencia
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 154a2543c62de545e8b2df711d6ad51989d0689d
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/22/2019
ms.locfileid: "69964847"
---
# <a name="dependency-property-metadata"></a>Metadatos de las propiedades de dependencia
El [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] sistema de propiedades incluye un sistema de informes de metadatos que va más allá de lo que se puede notificar sobre una propiedad a través de las características de reflexión o de Common Language Runtime general (CLR). Los metadatos de una propiedad de dependencia también los puede asignar de manera exclusiva la clase que define una propiedad de dependencia, se pueden cambiar cuando la propiedad de dependencia se agrega a una clase diferente y los pueden invalidar específicamente todas las clases derivadas que heredan la propiedad de dependencia de la clase base de definición.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Requisitos previos  
 En este tema, se supone que entiende las propiedades de dependencia desde la perspectiva de un consumidor de propiedades de dependencia existentes en las clases [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] y que ha leído [Información general sobre las propiedades de dependencia](dependency-properties-overview.md). Para seguir los ejemplos de este tema, también debe comprender el lenguaje [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y saber cómo escribir aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a>Uso de los metadatos de las propiedades de dependencia  
 Los metadatos de las propiedades de dependencia existen como un objeto que se puede consultar para examinar las características de una propiedad de dependencia. El sistema de propiedades también accede con frecuencia a estos metadatos mientras procesa cualquier propiedad de dependencia determinada. El objeto de metadatos de una propiedad de dependencia puede contener los siguientes tipos de información:  
  
- Valor predeterminado de la propiedad de dependencia, si no se puede determinar ningún otro valor para la propiedad de dependencia por valor local, estilo, herencia, etc. Para ver un análisis detallado de cómo participan los valores predeterminados en la precedencia que usa el sistema de propiedades al asignar valores de propiedades de dependencia, consulte [Prioridad de los valores de propiedades de dependencia](dependency-property-value-precedence.md).  
  
- Referencias a las implementaciones de devoluciones de llamada que afectan a los comportamientos de coerción o notificación de cambios por tipo de propietario. Tenga en cuenta que estas devoluciones de llamada se definen a menudo con un nivel de acceso no público, de modo que obtener las referencias reales de los metadatos no suele ser posible a menos que estén dentro de su ámbito de acceso permitido. Para obtener más información sobre las devoluciones de llamada de propiedades de dependencia, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](dependency-property-callbacks-and-validation.md).  
  
- Si la propiedad de dependencia en cuestión se considera una propiedad del nivel de marco de WPF, los metadatos podrían contener características de propiedades de dependencia del nivel de marco de WPF, que comunican los datos y el estado de los servicios, tales como la lógica de herencia de propiedades y el motor de diseño del nivel de marco de WPF. Para obtener más información sobre este aspecto de los metadatos de propiedades de dependencia, consulte [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md).  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a>API de metadatos  
 El tipo que notifica la mayor parte de la información de metadatos utilizada por el <xref:System.Windows.PropertyMetadata> sistema de propiedades es la clase. Las instancias de metadatos se especifican de manera opcional cuando las propiedades de dependencia se registran con el sistema de propiedades y pueden especificarse de nuevo para tipos adicionales que se agreguen a sí mismos como propietarios o invaliden los metadatos que heredan de la definición de propiedad de dependencia de clase base. (En los casos en los que un registro de propiedad no especifica metadatos, se crea un valor predeterminado <xref:System.Windows.PropertyMetadata> con los valores predeterminados para esa clase). Los metadatos registrados se devuelven como <xref:System.Windows.PropertyMetadata> cuando se llama a las diversas <xref:System.Windows.DependencyProperty.GetMetadata%2A> sobrecargas que obtienen los metadatos <xref:System.Windows.DependencyObject> de una propiedad de dependencia en una instancia.  
  
 La <xref:System.Windows.PropertyMetadata> clase se deriva de para proporcionar metadatos más específicos para las divisiones arquitectónicas, como las clases de nivel de marco de WPF. <xref:System.Windows.UIPropertyMetadata>agrega informes de animación y <xref:System.Windows.FrameworkPropertyMetadata> proporciona las propiedades del nivel de marco de WPF mencionadas en la sección anterior. Cuando se registran las propiedades de dependencia, se pueden registrar <xref:System.Windows.PropertyMetadata> con estas clases derivadas. Cuando se examinan los metadatos, <xref:System.Windows.PropertyMetadata> el tipo base puede convertirse potencialmente en las clases derivadas para que pueda examinar las propiedades más específicas.  
  
> [!NOTE]
> A veces, en esta documentación se hace <xref:System.Windows.FrameworkPropertyMetadata> referencia a las características de propiedad que se pueden especificar en, como "marcas". Cuando se crean nuevas instancias de metadatos para su uso en registros de propiedades de dependencia o invalidaciones de metadatos, estos valores <xref:System.Windows.FrameworkPropertyMetadataOptions> se especifican mediante la enumeración de marcadores y, a continuación, se proporcionan valores posiblemente concatenados de la enumeración al <xref:System.Windows.FrameworkPropertyMetadata> constructor. Sin embargo, una vez construidas, estas características de la <xref:System.Windows.FrameworkPropertyMetadata> opción se exponen en una como una serie de propiedades booleanas en lugar de crear el valor de enumeración. Las propiedades booleanas permiten comprobar cada condicional, en lugar de exigir que aplique una máscara a un valor de enumeración basada en marcas para obtener la información que le interesa. El constructor utiliza el objeto concatenado <xref:System.Windows.FrameworkPropertyMetadataOptions> para mantener la longitud de la firma del constructor razonable, mientras que los metadatos construidos reales exponen las propiedades discretas para hacer que las consultas de los metadatos sean más intuitivas.  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a>Cuándo invalidar metadatos y cuándo derivar una clase  
 El sistema de propiedades de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] tiene funcionalidades establecidas para modificar algunas características de las propiedades de dependencia sin necesidad de volver a implementarlas completamente. Esto se logra construyendo una instancia diferente de los metadatos de la propiedad de dependencia tal como existe en un tipo determinado. Tenga en cuenta que la mayoría de las propiedades de dependencia existentes no son propiedades virtuales, de modo que, en el sentido estricto, su "reimplementación" en clases heredadas solo se puede lograr mediante el sombreado del miembro existente.  
  
 Si el escenario que intenta habilitar para una propiedad de dependencia en un tipo no se puede lograr con la modificación de las características de las propiedades de dependencia existentes, podría ser necesario crear una clase derivada y, después, declarar una propiedad de dependencia personalizada en su clase derivada. Una propiedad de dependencia personalizada se comporta de forma idéntica a las propiedades de dependencia [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] definidas por las API. Para obtener más información acerca de las propiedades de dependencia personalizadas, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md).  
  
 Una característica importante de una propiedad de dependencia que no se puede invalidar es su tipo de valor. Si hereda una propiedad de dependencia que tiene el comportamiento aproximado que necesita, pero necesita que tenga un tipo diferente, tendrá que implementar una propiedad de dependencia personalizada y, posiblemente, vincular las propiedades mediante la conversión de tipos u otra implementación en la clase personalizada. Además, no puede reemplazar un existente <xref:System.Windows.ValidateValueCallback>, ya que esta devolución de llamada existe en el propio campo de registro y no en sus metadatos.  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a>Escenarios para modificar los metadatos existentes  
 Si está trabajando con los metadatos de una propiedad de dependencia existente, un escenario común para cambiar dichos metadatos es cambiar el valor predeterminado. Cambiar o agregar devoluciones de llamada del sistema de propiedades es un escenario más avanzado. Es posible que quiera hacerlo si su implementación de una clase derivada tiene diferentes interrelaciones entre las propiedades de dependencia. Uno de los condicionales de tener un modelo de programación que admita tanto el uso declarativo como de código es que las propiedades deben poder establecerse en cualquier orden. Por lo tanto, las propiedades dependientes deben establecerse Just-in-Time sin contexto y no pueden depender de saber un orden de configuración como podría darse en un constructor. Para obtener más información sobre este aspecto del sistema de propiedades, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](dependency-property-callbacks-and-validation.md). Tenga en cuenta que las devoluciones de llamada de validación no forman parte de los metadatos, sino del identificador de la propiedad de dependencia. Por lo tanto, las devoluciones de llamada de validación no se pueden cambiar mediante la invalidación de los metadatos.  
  
 Es posible que en algunos casos también quiera modificar las opciones de metadatos de la propiedad del nivel de marco de WPF en las propiedades de dependencia existente. Estas opciones comunican determinados condicionales conocidos acerca de las propiedades del nivel de marco de WPF a otros procesos del nivel de marco de WPF, como el sistema de diseño.  La configuración de las opciones se realiza normalmente solo cuando se registra una nueva propiedad de dependencia, pero también es posible cambiar los metadatos de la propiedad de nivel de marco <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> de <xref:System.Windows.DependencyProperty.AddOwner%2A> WPF como parte de una llamada a o. Para obtener los valores específicos que se van a usar y otros datos, consulte [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md). Para obtener más información relativa a cómo deben establecerse estas opciones para una propiedad de dependencia recién registrada, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a>Invalidar metadatos  
 El propósito de invalidar metadatos es principalmente que tenga la oportunidad de cambiar los distintos comportamientos derivados de metadatos que se aplican a la propiedad de dependencia tal como existe en el tipo. Las razones para ello se explican con más detalle en la sección [Metadatos](#dp_metadata_contents). Para obtener más información, incluidos algunos ejemplos de código, consulte [Invalidar metadatos en una propiedad de dependencia](how-to-override-metadata-for-a-dependency-property.md).  
  
 Se pueden proporcionar metadatos de propiedad para una propiedad de dependencia durante la<xref:System.Windows.DependencyProperty.Register%2A>llamada de registro (). Sin embargo, en muchos casos, es posible que quiera proporcionar metadatos específicos del tipo para la clase cuando esta herede esa propiedad de dependencia. Para ello, puede llamar al <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método.  Para obtener un ejemplo de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] las API, <xref:System.Windows.FrameworkElement> la clase es el tipo que registra primero la <xref:System.Windows.UIElement.Focusable%2A> propiedad de dependencia. Pero la <xref:System.Windows.Controls.Control> clase invalida los metadatos de la propiedad de dependencia para proporcionar su propio valor predeterminado inicial, que cambia `false` de `true`a y, de lo contrario, vuelve <xref:System.Windows.UIElement.Focusable%2A> a usar la implementación original.  
  
 Si invalida los metadatos, las distintas características de los metadatos se combinan o se reemplazan.  
  
- <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>se combina. Si agrega un nuevo <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, esa devolución de llamada se almacena en los metadatos. Si no especifica un <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se promueve como referencia del antecesor más cercano que lo especificó en los metadatos.  
  
- El comportamiento real del sistema de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> propiedades para es que las implementaciones de todos los propietarios de metadatos de la jerarquía se conserven y se agreguen a una tabla, con el orden de ejecución por parte del sistema de propiedades en el que se invocan primero las devoluciones de llamada de la clase más derivada.  
  
- <xref:System.Windows.PropertyMetadata.DefaultValue%2A>se ha reemplazado. Si no especifica un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.DefaultValue%2A> proviene del antecesor más cercano que lo especificó en los metadatos.  
  
- <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>las implementaciones se han reemplazado. Si agrega un nuevo <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, esa devolución de llamada se almacena en los metadatos. Si no especifica un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se promueve como referencia del antecesor más cercano que lo especificó en los metadatos.  
  
- El comportamiento del sistema <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de propiedades es que solo se invoca en los metadatos inmediatos. No se conserva ninguna <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> referencia a otras implementaciones en la jerarquía.  
  
 Implementa <xref:System.Windows.PropertyMetadata.Merge%2A>este comportamiento y se puede invalidar en clases de metadatos derivadas.  
  
#### <a name="overriding-attached-property-metadata"></a>Invalidar los metadatos de las propiedades adjuntas  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], las propiedades adjuntas se implementan como propiedades de dependencia. Esto significa que también tienen metadatos de propiedad, que las clases individuales pueden invalidar. Las consideraciones de ámbito para una propiedad adjunta [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] en son generalmente que <xref:System.Windows.DependencyObject> cualquiera puede tener una propiedad adjunta establecida en ellos. Por consiguiente, <xref:System.Windows.DependencyObject> cualquier clase derivada puede invalidar los metadatos de cualquier propiedad adjunta, como se podría establecer en una instancia de la clase. Puede invalidar valores predeterminados, devoluciones de llamada o propiedades de informes de características del nivel de marco de WPF. Si se establece la propiedad adjunta en una instancia de la clase, se aplicarán las características de invalidación de metadatos de propiedad. Por ejemplo, puede invalidar el valor predeterminado, de modo que el valor de invalidación se notifique como el valor de la propiedad adjunta en las instancias de la clase, siempre que la propiedad no esté establecida de otro modo.  
  
> [!NOTE]
> La <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propiedad no es relevante para las propiedades adjuntas.  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a>Agregar una clase como propietaria de una propiedad de dependencia existente  
 Una clase se puede Agregar a sí misma como propietario de una propiedad de dependencia que ya se ha registrado, <xref:System.Windows.DependencyProperty.AddOwner%2A> mediante el método. Esto permite que la clase use una propiedad de dependencia que se registró originalmente para un tipo diferente. La clase que se agrega no suele ser una clase derivada del tipo que registró inicialmente esa propiedad de dependencia como propietaria. De hecho, esto permite que la clase y sus clases derivadas "hereden" una implementación de propiedad de dependencia sin que la clase propietaria original y la clase que se agrega estén en la misma jerarquía de clases real. Además, la clase que se agrega (y también todas las clases derivadas) pueden proporcionar metadatos específicos del tipo para la propiedad de dependencia original.  
  
 Además de agregarse a sí misma como propietaria a través de los métodos de utilidad del sistema de propiedades, la clase que se agrega debe declarar miembros públicos adicionales en sí misma para convertir la propiedad de dependencia en un participante completo en el sistema de propiedades, con exposición para el código y la marcación. Una clase que agrega una propiedad de dependencia existente tiene las mismas responsabilidades en cuanto a exponer el modelo de objetos para esa propiedad de dependencia que una clase que define una nueva propiedad de dependencia personalizada. El primer miembro de este tipo que se va a exponer es un campo de identificador de propiedad de dependencia. Este campo debe ser un `public static readonly` campo de tipo <xref:System.Windows.DependencyProperty>, que se asigna al valor devuelto de la <xref:System.Windows.DependencyProperty.AddOwner%2A> llamada. El segundo miembro que se va a definir es la propiedad "contenedor" de Common Language Runtime (CLR). El contenedor hace que sea mucho más conveniente manipular la propiedad de dependencia en el código (se evitan <xref:System.Windows.DependencyObject.SetValue%2A> las llamadas a cada vez y puede hacer esa llamada solo una vez en el propio contenedor). El contenedor se implementa de forma idéntica a cómo se implementaría si se estuviera registrando una propiedad de dependencia personalizada. Para obtener más información acerca de cómo implementar una propiedad de dependencia, consulte [Propiedades de dependencia personalizadas](custom-dependency-properties.md) y [Agregar un tipo de propietario para una propiedad de dependencia](how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### <a name="addowner-and-attached-properties"></a>AddOwner y propiedades adjuntas  
 Puede llamar <xref:System.Windows.DependencyProperty.AddOwner%2A> a para una propiedad de dependencia que la clase propietaria define como una propiedad adjunta. Generalmente, el motivo para hacerlo es exponer la propiedad adjunta anteriormente como una propiedad de dependencia no adjunta. A continuación, expondrá <xref:System.Windows.DependencyProperty.AddOwner%2A> el valor devuelto `public static readonly` como un campo para su uso como identificador de la propiedad de dependencia y definirá las propiedades de "contenedor" apropiadas para que la propiedad aparezca en la tabla de miembros y admita una propiedad no adjunta. uso en la clase.  
  
## <a name="see-also"></a>Vea también

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [Información general sobre las propiedades de dependencia](dependency-properties-overview.md)
- [Metadatos de las propiedades de marco de trabajo](framework-property-metadata.md)
