---
title: Árboles en WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: f9b507c874dfe0ab3feca19e7fcf79df5af93e10
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/08/2019
ms.locfileid: "59197690"
---
# <a name="trees-in-wpf"></a>Árboles en WPF
En muchas tecnologías, los elementos y componentes se organizan en una estructura de árbol en la que los desarrolladores manipulan directamente los nodos de objeto en el árbol para modificar la representación o el comportamiento de una aplicación. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] También usa varias metáforas de la estructura de árbol para definir las relaciones entre elementos de programa. En su mayor parte, los desarrolladores de WPF pueden crear una aplicación en código o definir partes de la aplicación en código XAML mientras piensan conceptualmente en la metáfora de árbol de objetos, pero estarán llamando a una API concreta o usando un marcado concreto para llamarla, en lugar de usar una API de manipulación de árbol de objetos general como se usaría en DOM XML. WPF expone dos clases auxiliares que proporcionan una vista de metáfora de árbol, <xref:System.Windows.LogicalTreeHelper> y <xref:System.Windows.Media.VisualTreeHelper>. Los términos árbol visual y árbol lógico también se usan en la documentación de WPF porque estos mismos árboles son útiles para entender el comportamiento de ciertas características clave de WPF. En este tema define lo que representan el árbol visual y árbol lógico, se describe cómo se relacionan estos árboles con un concepto de árbol de objetos general y presenta <xref:System.Windows.LogicalTreeHelper> y <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Árboles en WPF  
 La estructura de árbol más completa de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] es el árbol de objetos. Si se define una página de aplicación en [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y después se carga el [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], se crea una estructura de árbol basada en las relaciones de anidamiento de los elementos del marcado. Si se define una aplicación o una parte de la aplicación en código, se crea la estructura de árbol en función de cómo se asignen los valores de propiedad de las propiedades que implementan el modelo de contenido para un objeto determinado. En [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], hay dos maneras de conceptualizar el árbol de objetos completo y de notificarlo a su API pública: como el árbol lógico y como el árbol visual. Las distinciones entre árbol lógico y árbol visual no son siempre importantes, pero en ocasiones pueden dar lugar a problemas con algunos subsistemas de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] y afectar a las decisiones que se toman en el marcado o el código.  
  
 Aunque no siempre se manipula directamente el árbol lógico o el árbol visual, entender los conceptos relativos a cómo interactúan ayuda a entender WPF como tecnología. Pensar en WPF como en un tipo de metáfora de árbol también es crucial para entender cómo funcionan la herencia de propiedades y el enrutamiento de eventos en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
>  Dado que el árbol de objetos es más un concepto que una API real, otra manera de pensar en el concepto es como un gráfico de objetos. En la práctica, hay relaciones entre los objetos en tiempo de ejecución en las que la metáfora del árbol no servirá. Pero la metáfora del árbol es lo bastante relevante para que la mayor parte de la documentación de WPF use el término árbol de objetos al hacer referencia a este concepto general, en especial con la interfaz de usuario definida en XAML.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>El árbol lógico  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], el contenido se agrega a los elementos de la interfaz de usuario estableciendo propiedades de los objetos que respaldan esos elementos. Por ejemplo, agrega elementos a un <xref:System.Windows.Controls.ListBox> control mediante la manipulación de su <xref:System.Windows.Controls.ItemsControl.Items%2A> propiedad. Al hacerlo, se colocan elementos en el <xref:System.Windows.Controls.ItemCollection> que es el <xref:System.Windows.Controls.ItemsControl.Items%2A> valor de propiedad. De forma similar, para agregar objetos a un <xref:System.Windows.Controls.DockPanel>, manipular su <xref:System.Windows.Controls.Panel.Children%2A> valor de propiedad. En este caso, se agregan objetos a la <xref:System.Windows.Controls.UIElementCollection>. Para obtener un ejemplo de código, vea [Cómo: Agregar dinámicamente un elemento](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 En [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], al colocar los elementos de lista en un <xref:System.Windows.Controls.ListBox> o controles u otros elementos de interfaz de usuario en un <xref:System.Windows.Controls.DockPanel>, también usa el <xref:System.Windows.Controls.ItemsControl.Items%2A> y <xref:System.Windows.Controls.Panel.Children%2A> propiedades, explícita o implícitamente, como en el ejemplo siguiente.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Si se procesara este código XAML como XML bajo un modelo de objetos de documento y se incluyeran como implícitas las etiquetas marcadas como comentario (lo que sería válido), el árbol DOM XML resultante incluiría elementos para `<ListBox.Items>` y los demás elementos implícitos. Pero XAML no se procesa de esta forma al leer el marcado y escribir en los objetos; el gráfico de objetos resultante no incluye literalmente `ListBox.Items`. Pero tiene un <xref:System.Windows.Controls.ListBox> propiedad denominada `Items` que contiene un <xref:System.Windows.Controls.ItemCollection>y que <xref:System.Windows.Controls.ItemCollection> se ha inicializado pero puede estar vacío cuando el <xref:System.Windows.Controls.ListBox> XAML se procesa. A continuación, cada elemento de objeto secundario que existe como contenido para el <xref:System.Windows.Controls.ListBox> se agrega a la <xref:System.Windows.Controls.ItemCollection> mediante llamadas del analizador a `ItemCollection.Add`. Este ejemplo de procesamiento de XAML en un árbol de objetos es hasta ahora aparentemente un ejemplo en el que el árbol de objetos creado es básicamente el árbol lógico.  
  
 Pero el árbol lógico no es el gráfico de objetos completo que existe en tiempo de ejecución para la interfaz de usuario de la aplicación, incluso con los elementos de sintaxis implícitos de XAML factorizados. La razón principal para esto son los elementos visuales y las plantillas. Por ejemplo, considere la <xref:System.Windows.Controls.Button>. Los informes del árbol lógico del <xref:System.Windows.Controls.Button> objeto y también su cadena `Content`. Pero este botón es más complejo en el árbol de objetos en tiempo de ejecución. En concreto, el botón sólo aparece en pantalla de la forma porque un determinado <xref:System.Windows.Controls.Button> se aplicó la plantilla de control. Los objetos visuales que proceden de una plantilla aplicada (como definido por la plantilla <xref:System.Windows.Controls.Border> de gris oscuro alrededor del botón visual) no se notifican en el árbol lógico, incluso si está buscando en el árbol lógico durante el tiempo de ejecución (como el control de un evento de entrada desde el interfaz de usuario visible y, a continuación, lee el árbol lógico). Para buscar los elementos visuales de la plantilla, sería necesario examinar el árbol visual en su lugar.  
  
 Para más información sobre cómo se asigna la sintaxis de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] al gráfico de objetos creado, y la sintaxis implícita en XAML, vea [Detalles de la sintaxis XAML](xaml-syntax-in-detail.md) o [Información general sobre XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Finalidad del árbol lógico  
 El árbol lógico existe para que los modelos de contenido puedan iterar fácilmente sus posibles objetos secundarios y para que los modelos de contenido puedan ser extensibles. Además, el árbol lógico proporciona un marco para algunas notificaciones, como, por ejemplo cuándo se cargan todos los objetos en él. Básicamente, el árbol lógico es una aproximación de un gráfico de objetos en tiempo de ejecución en el nivel de marco, que excluye los elementos visuales, pero es adecuado para muchas operaciones de consulta en la composición de su propia aplicación en tiempo de ejecución.  
  
 Además, las dos referencias de recursos estáticas y dinámicas se resuelven desplazándose hacia arriba por el árbol lógico para <xref:System.Windows.FrameworkElement.Resources%2A> colecciones en el objeto solicitante inicial y, a continuación, continuar con el árbol lógico y comprobar cada <xref:System.Windows.FrameworkElement> (o <xref:System.Windows.FrameworkContentElement>) por otro `Resources` valor que contiene un <xref:System.Windows.ResourceDictionary>, que posiblemente contenga esa clave. El árbol lógico se usa para la búsqueda de recursos cuando también está presente el árbol visual. Para más información sobre los diccionarios de recursos y la búsqueda, vea [Recursos XAML](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Composición del árbol lógico  
 El árbol lógico se define en el marco de WPF, lo que significa que el elemento de base de WPF más pertinente para las operaciones del árbol lógico sea <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Sin embargo, como puede ver si realmente utiliza la <xref:System.Windows.LogicalTreeHelper> API, el árbol lógico contiene a veces nodos que no son <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Por ejemplo, el árbol lógico notifica el <xref:System.Windows.Controls.TextBlock.Text%2A> valor de un <xref:System.Windows.Controls.TextBlock>, que es una cadena.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Invalidar el árbol lógico  
 Los autores de controles avanzados pueden invalidar el árbol lógico si invalidan varias [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] que definen la forma en que un objeto general o un modelo de contenido agrega o quita objetos en dicho árbol. Para obtener un ejemplo de cómo invalidar el árbol lógico, vea [Invalidar el árbol lógico](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Herencia de valores de propiedad  
 La herencia de valores de propiedad funciona a través de un árbol híbrido. Los metadatos reales que contienen el <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> propiedad que habilita la herencia de propiedad es el nivel de marco de WPF <xref:System.Windows.FrameworkPropertyMetadata> clase. Por lo tanto, el elemento primario que contiene el valor original y el objeto secundario que hereda ese valor deben ser <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, y deben formar parte de un árbol lógico. Pero para las propiedades de WPF existentes que admiten la herencia de propiedades, la herencia del valor de propiedad puede perpetuarse a través de un objeto intermedio que no está en el árbol lógico. Esto es especialmente pertinente para hacer que los elementos de plantilla usen cualquier valor de propiedad heredado establecido en la instancia basada en una plantilla o en los niveles aun más altos de composición de página y, por tanto, superiores en el árbol lógico. Para que la herencia del valor de propiedad funcione de forma coherente a través de un límite de este tipo, la propiedad que hereda se debe registrar como una propiedad adjunta y se debe seguir este patrón si se piensa definir una propiedad de dependencia personalizada con un comportamiento de herencia de propiedades. El árbol exacto que se usa para la herencia de propiedades no se puede prever completamente mediante un método de utilidad de clase del asistente, ni siquiera en tiempo de ejecución. Para más información, vea [Herencia de valores de propiedad](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>El árbol visual  
 Además del concepto de árbol lógico, en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] también existe el concepto de árbol visual. El árbol visual describe la estructura de objetos visuales, tal como está representada por la <xref:System.Windows.Media.Visual> clase base. Cuando se escribe una plantilla para un control, se define o se vuelve a definir el árbol visual aplicable a ese control. El árbol visual también tiene interés para los desarrolladores que quieren un control más específico sobre el dibujo por motivos de optimización y rendimiento. Una exposición del árbol visual como parte de la programación convencional de aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] consiste en que las rutas de evento de un evento enrutado recorren en su mayoría el árbol visual, no el árbol lógico. Esta sutileza de comportamiento de los eventos enrutados puede no resultar patente de forma inmediata salvo para los autores de controles. El enrutamiento de eventos a través del árbol visual permite que los controles que implementan la composición en el nivel visual controlen eventos o creen establecedores de eventos.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Árboles, elementos de contenido y hosts de contenido  
 Elementos de contenido (clases que derivan de <xref:System.Windows.ContentElement>) no forman parte del árbol visual; no se heredan de <xref:System.Windows.Media.Visual> y no tienen una representación visual. Para que aparezca en una interfaz de usuario en absoluto, una <xref:System.Windows.ContentElement> deben hospedarse en un host de contenido que es tanto un <xref:System.Windows.Media.Visual> y un participante en el árbol lógico. Normalmente, este tipo de objeto es un <xref:System.Windows.FrameworkElement>. Puede considerarse el host del contenido como una especie de "explorador" para el contenido que decide cómo mostrar ese contenido dentro de la zona de la pantalla que controla. Cuando se hospeda el contenido, puede participar en algunos procesos del árbol que suelen asociarse al árbol visual. Por lo general, el <xref:System.Windows.FrameworkElement> clase host incluye código de implementación que los hospedados agrega <xref:System.Windows.ContentElement> a la ruta del evento a través de subnodos del árbol lógico de contenido, aunque el contenido hospedado no forme parte del verdadero árbol visual. Esto es necesario para que un <xref:System.Windows.ContentElement> puede originar un evento enrutado que se enruta a cualquier elemento que no sea de sí mismo.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Exploración transversal del árbol  
 El <xref:System.Windows.LogicalTreeHelper> clase proporciona el <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, y <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> métodos para la exploración transversal del árbol lógico. En la mayoría de los casos, no debería tener que recorrer el árbol lógico de los controles existentes, porque casi siempre exponen sus elementos secundarios lógicos como una propiedad de colección dedicada que admite el acceso a colecciones como `Add`, un indexador, etc. Exploración transversal del árbol es principalmente un escenario que se usa por los autores de controles que optan por no derivar patrones de control previstos como <xref:System.Windows.Controls.ItemsControl> o <xref:System.Windows.Controls.Panel> donde ya están definidas las propiedades de la colección, y que desean proporcionar su propia colección compatibilidad con la propiedad.  
  
 El árbol visual también admite una clase auxiliar para la exploración transversal del árbol visual, <xref:System.Windows.Media.VisualTreeHelper>. El árbol visual no se expone como cómodamente a través de las propiedades específicas del control, por lo que la <xref:System.Windows.Media.VisualTreeHelper> clase es la manera recomendada de recorrer el árbol visual si fuera necesario para su escenario de programación. Para más información, consulte [Información general sobre la representación de gráficos en WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  A veces es necesario examinar el árbol visual de una plantilla aplicada. Se recomienda tener cuidado al usar esta técnica. Aunque se esté recorriendo un árbol visual para un control donde se debe definir la plantilla, los consumidores del control siempre pueden cambiar la plantilla estableciendo el <xref:System.Windows.Controls.Control.Template%2A> propiedad en las instancias e incluso el usuario final puede influir en la plantilla aplicada cambiando el tema del sistema.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Rutas para los eventos enrutados como un "árbol"  
 Como se ha mencionado antes, la ruta de cualquier evento enrutado determinado recorre una sola ruta de acceso predeterminada de un árbol, que es un híbrido de las representaciones del árbol visual y del árbol lógico. La ruta de evento puede recorrer el árbol hacia arriba o hacia abajo en función de si es un evento enrutado de tunelización o de propagación. El concepto de ruta de evento no tiene ninguna clase del asistente que lo respalde directamente y que se pueda usar para "recorrer" la ruta de evento con independencia de que se genere un evento que se enrute realmente. Hay una clase que representa la ruta, <xref:System.Windows.EventRoute>, pero los métodos de esa clase suelen ser solo para uso interno.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Diccionarios de recursos y árboles  
 La búsqueda de diccionarios de recursos para todos los `Resources` definidos en una página recorre básicamente el árbol lógico. Los objetos que no están en el árbol lógico pueden hacer referencia a recursos con clave, pero la secuencia de búsqueda de recursos se inicia en el punto donde ese objeto está conectado al árbol lógico. En WPF, solo los nodos de árbol lógico pueden tener un `Resources` propiedad que contiene un <xref:System.Windows.ResourceDictionary>, por lo tanto, no hay ninguna ventaja en recorrer el árbol visual que busca recursos con clave desde un <xref:System.Windows.ResourceDictionary>.  
  
 Pero la búsqueda de recursos también se puede extender más allá del árbol lógico inmediato. Para el marcado de la aplicación, la búsqueda de recursos puede continuar con los diccionarios de recursos de nivel de aplicación y, después, con los valores de compatibilidad y sistema de tema a los que se hace referencia como propiedades estáticas o claves. Los propios temas también pueden hacer referencia a valores del sistema situados fuera del árbol lógico del tema si las referencias de recurso son dinámicas. Para más información sobre los diccionarios de recursos y la lógica de búsqueda, vea [Recursos XAML](xaml-resources.md).  
  
## <a name="see-also"></a>Vea también

- [Información general sobre acciones del usuario](input-overview.md)
- [Información general sobre la representación de gráficos en WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Información general sobre eventos enrutados](routed-events-overview.md)
- [Inicialización de elementos de objeto no incluidos en un árbol de objetos](initialization-for-object-elements-not-in-an-object-tree.md)
- [Arquitectura de WPF](wpf-architecture.md)
