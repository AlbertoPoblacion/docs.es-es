---
title: Marcar eventos enrutados como controlados y control de clases
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: a1004ce10baf6293c4c93efc61b91b3b6361377f
ms.sourcegitcommit: eaa6d5cd0f4e7189dbe0bd756e9f53508b01989e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/07/2019
ms.locfileid: "67610369"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Marcar eventos enrutados como controlados y control de clases
Los controladores de un evento enrutado pueden marcar el evento como controlado en los datos del evento. Controlar el evento acorta de forma efectiva la ruta. El control de clases es un concepto de programación que admiten los eventos enrutados. Un controlador de clases tiene la oportunidad de controlar un evento enrutado determinado en un nivel de clase con un controlador que se invoca antes que cualquier controlador de instancias de cualquier instancia de la clase.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Requisitos previos  
 En este tema se profundiza sobre los conceptos presentados en [Información general sobre eventos enrutados](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Cuándo se deben marcar los eventos como controlados  
 Al establecer el valor de la <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad `true` en el evento datos para un evento enrutado, esto se conoce como "marcar el evento como controlado". No hay ninguna regla absoluta sobre cuándo se deben marcar los eventos enrutados como controlados como autor de una aplicación o como autor de control que responde a eventos enrutados existentes o implementa nuevos eventos enrutados. En su mayor parte, el concepto de "controlado" integrado en los datos de evento del evento enrutado debe usarse como protocolo limitado para las respuestas de su propia aplicación a los diversos eventos enrutados expuestos en [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], así como para cualquier evento enrutado personalizado. Otra forma de considerar la cuestión del "control" es que, generalmente, debería marcar un evento enrutado como controlado si el código respondió al evento enrutado de manera significativa y relativamente completa. Normalmente, no debería haber más de una respuesta significativa que requiera implementaciones del controlador independientes para cualquier instancia de evento enrutado. Si se necesitan más respuestas, se debe implementar el código necesario a través de la lógica de la aplicación encadenada con un único controlador, en lugar de usar el sistema de eventos enrutados para el reenvío. El concepto de "significativo" también es subjetivo y depende de la aplicación o el código. Como guía general, estos son algunos ejemplos de "respuesta significativa": establecer el foco, modificar el estado público, establecer propiedades que afectan a la representación visual y generar otros eventos nuevos. Ejemplos de respuestas no significativas: modificar el estado privado (sin impacto visual ni representación de programación), registrar eventos o examinar los argumentos de un evento y decidir no responder a él.  
  
 El comportamiento del sistema de eventos enrutados refuerza este modelo de "respuesta significativa" para usar el estado controlado de un evento enrutado, porque los controladores agregados en [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] o la firma común de <xref:System.Windows.UIElement.AddHandler%2A> no se invocan en respuesta a un evento enrutado donde el evento datos ya está marcado como controlados. Debe pasar por el esfuerzo de agregar un controlador con el `handledEventsToo` parámetro version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) con el fin de controlar los eventos enrutados marcados como controlados participantes anteriores en la ruta de eventos.  
  
 En algunas circunstancias, los propios controles marcan ciertos eventos enrutados como controlados. Un evento enrutado controlado representa una decisión de los autores de control de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] por la que las acciones del control de respuesta al evento enrutado son significativas o completas como parte de la implementación del control, y el evento no necesita ningún otro control. Normalmente, para hacerlo, se agrega un controlador de clase para un evento o se reemplaza uno de los elementos virtuales de controlador de clase que existen en una clase base. Si es necesario, puede resolver el control de eventos. Consulte [Solución de la supresión de eventos mediante controles](#WorkingAroundEventSuppressionByControls) más adelante en este tema.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Comparación de eventos de "vista previa" (tunelización) y de propagación, y control de eventos  
 Los eventos enrutados de vista previa son eventos que siguen una ruta de tunelización a través del árbol de elementos. "Preview", expresado en la convención de nomenclatura, indica el principio general para los eventos de entrada que establece que los eventos enrutados de vista previa (tunelización) se generan antes que el evento enrutado de propagación equivalente. Además, los eventos enrutados de entrada que tienen un par de tunelización y propagación tienen una lógica de control distinta. Si un agente de escucha de eventos marca el evento enrutado de tunelización/vista previa, el evento enrutado de propagación se marcará como controlado incluso antes de que cualquier agente de escucha de evento enrutado de propagación lo reciba. Los eventos enrutados de tunelización y propagación son, técnicamente, eventos independientes, pero comparten deliberadamente la misma instancia de datos de evento para habilitar este comportamiento.  
  
 La conexión entre los eventos enrutados de tunelización y propagación se realiza mediante la implementación interna de cómo cualquier clase de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] determinada genera sus propios eventos enrutados declarados, y este es el caso de los eventos enrutados de entrada emparejados. Sin embargo, a menos que exista esta implementación de nivel de clase, no hay ninguna conexión entre un evento enrutado de tunelización y uno de propagación que comparten el esquema de nomenclatura: sin tal implementación, serían dos eventos enrutados completamente independientes y no se generarían en secuencia ni compartirían datos de evento.  
  
 Para obtener más información sobre cómo implementar pares de eventos enrutados de entrada de tunelización y propagación en una clase personalizada, consulte [Cómo: Crear un evento enrutado personalizado](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Controladores de clases y controladores de instancias  
 Los eventos enrutados consideran dos tipos distintos de agentes de escucha para el evento: de clase y de instancia. Los agentes de escucha de clase existen porque los tipos han llamado a un determinado <xref:System.Windows.EventManager> API,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, en su constructor estático, o han invalidado un método virtual de controlador de clase de una clase base del elemento. Los agentes de escucha de instancia son instancias de clase en particular o elementos que se adjuntaron uno o varios controladores para ese evento enrutado mediante una llamada a <xref:System.Windows.UIElement.AddHandler%2A>. Existente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eventos enrutados realizan llamadas a <xref:System.Windows.UIElement.AddHandler%2A> como parte de la [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] agregar contenedor de eventos{} y quitar{} implementaciones del evento, que también es la forma simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mecanismo de adjuntar controladores de eventos a través de una sintaxis de atributo está habilitada. Por tanto, incluso los más sencillos [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] uso equivale a un <xref:System.Windows.UIElement.AddHandler%2A> llamar.  
  
 Se comprueban las implementaciones de controlador registradas de los elementos del árbol visual. Los controladores se pueden invocar a lo largo de la ruta en el orden inherente al tipo de la estrategia de enrutamiento para el evento enrutado. Por ejemplo, los eventos enrutados de propagación invocan primero los controladores adjuntos al mismo elemento que generó el evento enrutado. A continuación, el evento enrutado "se propaga" en el siguiente elemento primario y así sucesivamente hasta que se alcanza el elemento raíz de aplicación.  
  
 Desde la perspectiva del elemento raíz en una ruta de propagación, si el control de clases o cualquier elemento más cercano al origen del evento enrutado invoca controladores que marcan los argumentos de evento como controlados, no se invocan controladores en los elementos raíz y la ruta del evento se acorta eficazmente antes de llegar al elemento raíz. Sin embargo, la ruta no se detiene por completo, ya que se pueden agregar controladores mediante la condición especial de que se deben invocar igualmente, incluso si un controlador de clase o de instancia ha marcado el evento enrutado como controlado. Esto se explica en [Adición de controladores de instancias que se generan incluso cuando los eventos se marcan como controlados](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), más adelante en este tema.  
  
 En un nivel más profundo que la ruta del evento, también puede haber varios controladores de clases que actúen en cualquier instancia de una clase. Esto se debe a que el modelo de control de clase para los eventos enrutados permite que todas las clases posibles de una jerarquía de clases registren su propio controlador de clase para cada evento enrutado. Cada controlador de clase se agrega a un almacén interno y, cuando se construye la ruta de eventos para una aplicación, todos los controladores de clase se agregan a la ruta del evento. Los controladores de clase se agregan a la ruta de modo que el controlador de la clase más derivada se invoca primero y los controladores de clase de cada clase base sucesiva se invocan después. Por lo general, los controladores de clase no están registrados por lo que también responden a eventos enrutados que ya se marcaron como controlados. Por consiguiente, este mecanismo de control de clases habilita una de dos opciones:  
  
- Las clases derivadas pueden complementar el control de clases que se hereda de la clase base agregando un controlador que no marca el evento enrutado como controlado, porque el controlador de la clase base se invocará después del controlador de la clase derivada.  
  
- Las clases derivadas pueden reemplazar el control de clases de la clase base agregando un controlador de clase que marque el evento enrutado como controlado. Debe tener cuidado con este enfoque, porque es posible que cambie el diseño del control de base deseado en áreas como el aspecto visual, la lógica de estado, el control de entrada y la gestión de comandos.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Control de clases de eventos enrutados mediante clases base de control  
 En cada nodo de elemento dado de una ruta de eventos, los agentes de escucha de clase tienen la oportunidad de responder al evento enrutado antes que cualquier agente de escucha de instancia en el elemento. Por este motivo, los controladores de clase se usan a veces para suprimir eventos enrutados que una implementación de clase de control determinada no quiere que se propaguen más o para proporcionar un control especial de ese evento enrutado que es una característica de la clase. Por ejemplo, una clase podría generar su propio evento específico de clase con información más específica sobre el significado de alguna condición de entrada de usuario en el contexto de esa clase en particular. La implementación de la clase, a continuación, puede marcar el evento enrutado más general como controlado. Los controladores de clase se agregan normalmente tal que no se invocan para enrutar controlan los eventos donde los datos de evento compartidos ya estaban marcados, pero para casos atípicos también hay un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> firma que registra los controladores de clase para invocar incluso cuando son eventos enrutados marcado como controlado.  
  
### <a name="class-handler-virtuals"></a>Elementos virtuales de controlador de clase  
 Algunos elementos, particularmente los elementos base, como <xref:System.Windows.UIElement>, exponen vacío "en * Event" y "OnPreview\*eventos" métodos virtuales que corresponden a su lista de eventos enrutados públicos. Estos métodos virtuales se pueden invalidar para implementar un controlador de clase para el evento enrutado. Las clases de elementos base registran estos métodos virtuales como su controlador de clase para cada uno de estos enruta eventos mediante <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> como se describió anteriormente. Los métodos virtuales On\*Event facilitan la implementación del control de clases para los eventos enrutados pertinentes, sin necesidad de una inicialización especial en constructores estáticos para cada tipo. Por ejemplo, puede agregar control de clases para el <xref:System.Windows.UIElement.DragEnter> eventos en cualquier <xref:System.Windows.UIElement> clase derivada invalidando el <xref:System.Windows.UIElement.OnDragEnter%2A> método virtual. Dentro de la invalidación, podría controlar el evento enrutado, generar otros eventos, iniciar una lógica específica de clase que podría cambiar las propiedades de elemento en instancias, o cualquier combinación de esas acciones. Por lo general, debe llamar a la implementación base en dichas invalidaciones incluso si marca el evento como controlado. Se recomienda llamar a la implementación base porque el método virtual se encuentra en la clase base. El patrón virtual protegido estándar de llamar a las implementaciones base desde cada elemento virtual, básicamente, reemplaza y es comparable a un mecanismo similar que es nativo al control de clases de eventos enrutados, mediante el cual se llama a los controladores de clase de todas las clases de una jerarquía de clases en una instancia determinada, comenzando por el controlador de la clase más derivada y continuando hasta el controlador de la clase base. Solo se debe omitir la llamada de implementación base si la clase tiene un requisito deliberado para cambiar la lógica de control de clase base. Si se llama a la implementación base antes o después, el código de invalidación dependerá de la naturaleza de la implementación.  
  
#### <a name="input-event-class-handling"></a>Control de clase de evento de entrada  
 Los métodos virtuales de controlador de clase se registran de modo que solo se invocan en casos donde ya no se marcan los datos de evento compartidos como controlados. Además, solo para los eventos de entrada, las versiones de tunelización y propagación, normalmente, se producen en secuencia y comparten datos de eventos. Esto supone que, para un par determinado de controladores de clase de eventos de entrada, donde uno es la versión de tunelización y el otro, la de propagación, no es recomendable marcar el evento como controlado inmediatamente. Si implementa el método virtual de control de clase de tunelización para marcar el evento como controlado, el controlador de clase de propagación no se podrá invocar (además de impedir que se invoque cualquier controlador de instancias registrado normalmente para el evento de tunelización o propagación).  
  
 Una vez completado el control de clases en un nodo, se consideran los agentes de escucha de instancia.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Adición de controladores de instancias que se generan incluso cuando los eventos se marcan como controlados  
 El <xref:System.Windows.UIElement.AddHandler%2A> método proporciona una sobrecarga determinada que le permite agregar controladores que invocará el sistema de eventos cada vez que un evento alcance el elemento de control de la ruta, incluso si algún otro controlador ya ha ajustado para marcar que los datos del evento evento como controlado. Normalmente, esto no se hace. Por lo general, se pueden escribir controladores para ajustar todas las áreas del código de aplicación que podrían verse afectadas por un evento, independientemente de dónde se controlara en un árbol de elementos, incluso si se quieren varios resultados finales. Además, normalmente, solo hay un elemento que necesite responder a ese evento y la lógica de aplicación adecuada ya se ha ejecutado. Pero la sobrecarga `handledEventsToo` está disponible para los casos excepcionales en que otro elemento de una composición de control o árbol de elementos ya se ha marcado como controlado, pero otros elementos superiores o inferiores del árbol de elementos (dependiendo de la ruta) aún quieren tener sus propios controladores invocados.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Cuándo se deben marcar los eventos controlados como no controlados  
 Por lo general, los eventos enrutados marcados como controlados no se deben marcar no controlados (<xref:System.Windows.RoutedEventArgs.Handled%2A> vuelve a establecer en `false`) incluso por los controladores que actúan sobre `handledEventsToo`. Sin embargo, algunos eventos de entrada tienen representaciones de eventos de alto nivel y de nivel inferior que pueden superponerse cuando el evento de alto nivel se ve en una posición en el árbol y el evento de bajo nivel en otra posición. Por ejemplo, considere el caso donde un elemento secundario escuche un evento de tecla de alto nivel como <xref:System.Windows.UIElement.TextInput> mientras un elemento primario escucha un evento de bajo nivel como <xref:System.Windows.UIElement.KeyDown>. Si el elemento primario controla el evento de bajo nivel, el evento de nivel superior se puede suprimir incluso en el elemento secundario que, intuitivamente, debería tener la primera oportunidad de controlar el evento.  
  
 En estas situaciones, puede ser necesario agregar controladores a los elementos primarios y secundarios para el evento de bajo nivel. La implementación del controlador del elemento secundario puede marcar el evento de bajo nivel como controlado, pero la implementación del controlador del elemento primario lo marcaría de nuevo como no controlado para que los elementos superiores del árbol (así como el evento de alto nivel) puedan tener la oportunidad de responder. Esta situación debería ser poco frecuente.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Supresión deliberada de eventos de entrada para la composición de control  
 El escenario principal donde se utiliza el control de clases de eventos enrutados es para los eventos de entrada y los controles compuestos. Un control compuesto está, por definición, compuesto por varios controles prácticos o clases base de control. A menudo, el autor del control quiere amalgamar todos los posibles eventos de entrada que cada uno de los subcomponentes pueda generar a fin de notificar todo el control como el origen del evento singular. En algunos casos, puede que el autor del control quiera suprimir los eventos de los componentes por completo o sustituir un evento definido por el componente que lleva más información o implica un comportamiento más concreto. El ejemplo canónico que resulta evidente para cualquier autor de componentes es cómo un [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> controla cualquier evento del mouse que finalmente se resolverá como el evento intuitivo que tienen todos los botones: un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 El <xref:System.Windows.Controls.Button> clase base (<xref:System.Windows.Controls.Primitives.ButtonBase>) se deriva de <xref:System.Windows.Controls.Control> que a su vez se deriva de <xref:System.Windows.FrameworkElement> y <xref:System.Windows.UIElement>y gran parte de la infraestructura de eventos necesaria para controlar el procesamiento de entrada está disponible en el <xref:System.Windows.UIElement> nivel. En concreto, <xref:System.Windows.UIElement> procesa general <xref:System.Windows.Input.Mouse> acciones, botón de eventos que controlan la prueba de posicionamiento para el cursor del mouse dentro de sus límites y proporciona eventos distintos para los más comunes, como <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> También proporciona un valor vacío virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> como el controlador de clase previamente registrado para <xref:System.Windows.UIElement.MouseLeftButtonDown>, y <xref:System.Windows.Controls.Primitives.ButtonBase> lo invalida. De forma similar, <xref:System.Windows.Controls.Primitives.ButtonBase> usa controladores para la clase <xref:System.Windows.UIElement.MouseLeftButtonUp>. En las invalidaciones, que se pasan los datos de eventos, las implementaciones marcan <xref:System.Windows.RoutedEventArgs> instancia como controlado estableciendo <xref:System.Windows.RoutedEventArgs.Handled%2A> a `true`, y que los mismos datos de evento están continúan a lo largo del resto de la ruta a otros controladores de clase y también para los controladores de instancias o establecedores de eventos. Además, el <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> invalidación a continuación, se producirá la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos. El resultado final para la mayoría de los agentes de escucha que será el <xref:System.Windows.UIElement.MouseLeftButtonDown> y <xref:System.Windows.UIElement.MouseLeftButtonUp> eventos "desaparezca" y se reemplazan en su lugar por <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un evento que contiene lo que significa más porque se sabe que se ha originado este evento desde un botón true y no a algunas composición de piezas del botón o desde algún otro elemento completamente.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Solución de la supresión de eventos mediante controles  
 A veces, este comportamiento de supresión de eventos en controles individuales puede interferir con algunas intenciones más generales de la lógica de control de eventos de la aplicación. Por ejemplo, si por algún motivo la aplicación tenía un controlador para <xref:System.Windows.UIElement.MouseLeftButtonDown> ubicado en el elemento raíz de aplicación, observaría que cualquier clic del mouse en un botón no invocaría <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> controladores en el nivel raíz. En realidad, el evento en sí se propagó hacia arriba (de nuevo, las rutas de evento no están finalizadas realmente, pero el sistema de eventos enrutados cambia su comportamiento de invocación de controlador después de marcarse como controlado). Cuando el evento enrutado alcanza el botón, el <xref:System.Windows.Controls.Primitives.ButtonBase> control de clases se marca el <xref:System.Windows.UIElement.MouseLeftButtonDown> controlado porque quería sustituir el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos con más significado. Por lo tanto, ningún estándar <xref:System.Windows.UIElement.MouseLeftButtonDown> no sería necesario invocar controlador aún más arriba en la ruta. Hay dos técnicas que puede usar para asegurarse de que los controladores se invoquen en estas circunstancias.  
  
 La primera técnica consiste en agregar deliberadamente el controlador usando el `handledEventsToo` firma de <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Una limitación de este enfoque es que esta técnica para adjuntar un controlador de eventos solo es posible desde el código, no desde el marcado. La sintaxis simple de especificar el nombre del controlador de eventos como un valor de atributo de evento a través de [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] no permite ese comportamiento.  
  
 La segunda técnica solo funciona para los eventos de entrada, donde se emparejan las versiones de tunelización y propagación del evento enrutado. Para estos eventos enrutados, también puede agregar controladores al evento enrutado equivalente de tunelización/vista previa. El evento enrutado se tunelizará por la ruta partiendo de la raíz, por lo que el código de control de clase del botón no lo interceptaría, siempre que haya adjuntado el controlador Preview en algún nivel de elemento antecesor en el árbol de elementos de la aplicación. Si usa este enfoque, tenga cuidado al marcar cualquier evento Preview como controlado. Para el ejemplo proporcionado con <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> controlado en el elemento raíz, si marcara el evento como <xref:System.Windows.RoutedEventArgs.Handled%2A> en la implementación del controlador, suprimiría el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos. Normalmente, no es un comportamiento deseable.  
  
## <a name="see-also"></a>Vea también

- <xref:System.Windows.EventManager>
- [Eventos de vista previa](preview-events.md)
- [Crear un evento enrutado personalizado](how-to-create-a-custom-routed-event.md)
- [Información general sobre eventos enrutados](routed-events-overview.md)
