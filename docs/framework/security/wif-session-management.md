---
title: Administración de sesiones de WIF
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 141eda509530cab1120d519c3cbc94693ef1cc51
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/22/2019
ms.locfileid: "69946237"
---
# <a name="wif-session-management"></a>Administración de sesiones de WIF
Cuando un cliente intenta acceder a un recurso protegido hospedado en un usuario de confianza por primera vez, primero debe autenticarse en un servicio de token de seguridad (STS) que sea de confianza para el usuario de confianza. Luego el STS emite un token de seguridad al cliente. El cliente presenta este token al usuario de confianza, que, entonces, le concede acceso al recurso protegido. Pero no es deseable que el cliente tenga que volver a autenticarse en el STS para cada solicitud, sobre todo porque incluso podría no ser en el mismo equipo o en el mismo dominio que el usuario de confianza. Así, Windows Identity Foundation (WIF) hace que el cliente y el usuario de confianza establezcan una sesión en la que el cliente usa un token de seguridad de sesión para autenticarse en el usuario de confianza para todas las solicitudes después de la primera. El usuario de confianza puede usar este token de seguridad de sesión, que se almacena en una cookie, para reconstruir el elemento <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> del cliente.  
  
 El STS define qué autenticación debe proporcionar el cliente. Pero el cliente puede tener varias credenciales con las que se puede autenticar en el STS. Por ejemplo, puede tener un token de Windows Live, un nombre de usuario y una contraseña, un certificado y una smartkey. En ese caso, el STS concede al cliente varias identidades, cada una de las cuales corresponde a una de las credenciales que presenta el cliente. El usuario de confianza puede usar una o varias de estas identidades cuando decide qué nivel de acceso concede al cliente.  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> se usa para reconstruir el elemento <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> del cliente, que contiene todas las identidades del cliente en <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>. Cada <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> de la colección contiene los tokens de arranque asociados a esa identidad.  
  
 Si se emite un nuevo token de sesión con el identificador de sesión del token de sesión original, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> no actualiza el token de sesión en la caché de tokens. Siempre debe crear una instancia de un token de sesión con un identificador de sesión único.  
  
> [!NOTE]
> Session.SecurityTokenHandler.ReadToken produce una excepción <xref:System.Xml.XmlException> si recibe una entrada no válida; por ejemplo, si la cookie que contiene el token de sesión está dañada. Se recomienda detectar esta excepción y proporcionar un comportamiento específico de la aplicación.  
  
 Si una página web protegida contiene una gran cantidad de recursos (por ejemplo, gráficos pequeños) que también están en el dominio protegido, el cliente debe volver a autenticarse en el usuario de confianza para descargar cada uno de esos recursos. El empleo de un token de autenticación de sesión evita la necesidad de autenticarse en el STS para cada solicitud, pero significa que aún se están enviando muchas cookies. Es posible que quiera configurar la página web de modo que los datos y los recursos importantes se almacenen en el dominio protegido, mientras que los elementos secundarios lo hagan en un dominio no protegido y vinculado desde la página web principal. Además, establezca la ruta de acceso de la cookie de modo que haga referencia solo al dominio protegido.  
  
 Para funcionar en modo de referencia, Microsoft recomienda proporcionar un controlador para el evento <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> en el archivo **global.asax.cs** y establecer la propiedad **IsReferenceMode** en el token pasado en la propiedad <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A>. Estas actualizaciones garantizan que el token de sesión funcione en modo de referencia para cada solicitud y que se prefiera al mero establecimiento de la propiedad <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> en el módulo de autenticación de sesión.  
  
## <a name="extensibility"></a>Extensibilidad  
 Puede extender el mecanismo de administración de sesión. Una razón para hacerlo es mejorar el rendimiento. Por ejemplo, puede crear un controlador de cookies personalizado que transforme u optimice el token de seguridad de sesión entre su estado en memoria y lo que se incluye en la cookie. Para ello, puede configurar la propiedad <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> de <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> para usar un controlador de cookies personalizado que derive de <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>. <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> es el controlador de cookies predeterminado porque las cookies superan el tamaño permitido para el protocolo de transferencia de hipertexto (HTTP); si usa un controlador de cookies personalizado, debe implementar la fragmentación.  
  
 Para obtener más información, vea ejemplo de [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) . Este ejemplo muestra una memoria caché de sesión lista para una granja de servidores (en lugar de un elemento tokenreplycache) para que pueda usar sesiones por referencia en lugar de intercambiar cookies grandes; este ejemplo también muestra una manera más sencilla de proteger las cookies de una granja de servidores. La caché de sesión se basa en WCF. Con respecto a la protección de sesión, el ejemplo muestra una nueva capacidad de WIF 4.5: una transformación de cookies basada en MachineKey que puede activarse con solo pegar el fragmento de código adecuado en web.config. El ejemplo en sí mismo no es una "granja", pero muestra lo que se necesita para hacer que la aplicación esté lista para una granja de servidores.
